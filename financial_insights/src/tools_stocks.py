import datetime
import json
import os
from datetime import timedelta
from typing import Any, Dict, List, Optional, Tuple

import pandas
import requests  # type: ignore
import streamlit
import yfinance
from langchain.output_parsers import PydanticOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_core.tools import tool

# from langchain_core.pydantic_v1 import BaseModel, Field
from llama_index.core.bridge.pydantic import BaseModel, Field
from matplotlib import dates as mdates
from matplotlib import pyplot
from matplotlib.figure import Figure
from pandasai import SmartDataframe
from pandasai.connectors.yahoo_finance import YahooFinanceConnector

from financial_insights.src.tools import coerce_str_to_list, convert_data_to_frame, extract_yfinance_data
from financial_insights.streamlit.constants import *


class StockInfoSchema(BaseModel):
    """Return the correct stock information given the appropriate ticker symbol."""

    user_query: str = Field('User query to retrieve stock information.')
    symbol_list: List[str] | str = Field('List of stock ticker symbols.')
    dataframe_name: Optional[str] = Field('Name of the dataframe to be used.')


class TickerSymbol(BaseModel):
    """The ticker symbol of the company"""

    symbol: str = Field('The ticker symbol of the company')


@tool(args_schema=StockInfoSchema)
def get_stock_info(
    user_query: str, symbol_list: List[str] | str, dataframe_name: Optional[str] = None
) -> Dict[str, str]:
    """
    Return the correct stock information given the appropriate ticker symbol.

    Args:
        user_query: User query to retrieve stock information.
        symbol_list: List of stock ticker symbols.
        dataframe_name: Name of the dataframe to be used.

    Returns:
        Dictionary containing the correct stock information (value) for a given ticker symbol (key).

    Raises:
        TypeError: If `user_query` is not a string or `symbol_list` is not a list of strings,
            or `dataframe_name` is not a string.
    """
    # Checks the inputs
    assert isinstance(user_query, str), TypeError(f'User query must be of type string. Got {(type(user_query))}.')
    assert isinstance(symbol_list, (list, str)), TypeError(
        f'Symbol list must be of type list or string. Got {(type(symbol_list))}.'
    )

    # If `symbol_list` is a string, coerce it to a list of strings
    symbol_list = coerce_str_to_list(symbol_list)

    assert all(isinstance(symbol, str) for symbol in symbol_list), TypeError(
        'All elements in the symbol list must be of type string.'
    )
    assert isinstance(dataframe_name, str | None), TypeError(
        f'Dataframe name must be a string. Got {(type(dataframe_name))}.'
    )

    response_dict: Dict[str, str] = dict()

    for symbol in symbol_list:
        # If the user has not provided a dataframe name then use the generic yfinance langchain connector
        if dataframe_name is None:
            response_dict[symbol] = yahoo_connector_answer(user_query, symbol)
        # If the user has provided a dataframe name then use the custom langchain connector
        else:
            # Extract the relevant yfinance data
            company_data_dict = extract_yfinance_data(
                symbol,
                start_date=datetime.datetime.today().date() - timedelta(days=365),
                end_date=datetime.datetime.today().date(),
            )

            # Extract the relevant dataframe from the yfinance data dictionary
            data = company_data_dict[dataframe_name]
            # Coerce the retrieved data to a `pandas.DataFrame`
            dataframe = convert_data_to_frame(data, dataframe_name)

            try:
                # Instantiate a `pandasai.SmartDataframe` object
                df = SmartDataframe(
                    dataframe,
                    config={
                        'llm': streamlit.session_state.fc.llm,
                        'open_charts': False,
                        'save_charts': True,
                        'save_charts_path': STOCK_QUERY_FIGURES_DIR,
                        'enable_cache': False,
                    },
                )

                # Answer the user query by symbol
                response_dict[symbol] = df.chat(user_query)
            except:
                # If the answer could not be generated, then use the generic yfinance langchain connector
                response_dict[symbol] = yahoo_connector_answer(user_query, symbol)

    return response_dict


def yahoo_connector_answer(user_query: str, symbol: str) -> Any:
    """
    Answer the user query using the generic `pandasai.connectors.yahoo_finance.YahooFinanceConnector`.

    Args:
        user_query: The user query to answer.
        symbol: The company symbol for which to retrieve data from yfinance.

    Returns:
        The response generated by the connector.

    Raises:
        TypeError: If `user_query` is not a string or symbol is not a string.
    """
    # Checks the inputs
    assert isinstance(user_query, str), TypeError(f'The user query must be of type string. Got {(type(user_query))}.')
    assert isinstance(symbol, str), TypeError(f'The company symbol must be of type string. Got {(type(symbol))}.')

    # Instantiate a `pandasai.connectors.yahoo_finance.YahooFinanceConnector` object with the relevant symbol
    yahoo_connector = YahooFinanceConnector(symbol)

    # Instantiate a `pandasai.SmartDataframe` object with the relevant connector and user query
    df = SmartDataframe(
        yahoo_connector,
        config={
            'llm': streamlit.session_state.fc.llm,
            'open_charts': False,
            'save_charts': True,
            'save_charts_path': STOCK_QUERY_FIGURES_DIR,
            'enable_cache': False,
        },
    )

    # Answer the user query by symbol
    return df.chat(user_query)


class RetrievalCompanyNameSchema(BaseModel):
    """Retrieve a list of company names."""

    company_names_list: List[str] | str = Field('List of company names to retrieve from the query.')


@tool(args_schema=RetrievalCompanyNameSchema)
def retrieve_symbol_list(company_names_list: List[str] | str = list()) -> Optional[List[str]]:
    """
    Retrieve a list of ticker symbols.

    Args:
        company_names_list: List of company names to search for in the JSON file.

    Returns:
        Tuple of a list of ticker symbols and the user query.

    Raises:
        TypeError: If `company_names_list` is not of type list or string.
    """
    # Check inputs
    assert isinstance(company_names_list, (list, str)), TypeError(
        f'company_names_list` names must be a list of strings. Got {type(company_names_list)}.'
    )

    # If `symbol_list` is a string, coerce it to a list of strings
    company_names_list = coerce_str_to_list(company_names_list)

    if len(company_names_list) == 0:
        return list()

    assert all([isinstance(name, str) for name in company_names_list]), TypeError(
        '`company_names_list` must be a list of strings.'
    )

    # URL to the JSON file
    url = 'https://www.sec.gov/files/company_tickers.json'

    # Fetch the JSON data from the URL
    response = requests.get(url)

    symbol_list = list()

    # Specify the file path where you want to save the JSON data
    file_path = kit_dir + '/company_tickers.json'

    # Check if the request was successful
    if response.status_code == 200:
        data = response.json()

        # Save the DataFrame to a json file
        if not os.path.exists(kit_dir):
            os.makedirs(kit_dir)

        # Write the JSON data to the file
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

    else:
        # Load JSON data from the file
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

    # Iterate over the JSON data to extract ticker symbols
    for company in company_names_list:
        # The prompt template
        prompt_template_symbol = (
            'What is the ticker symbol for {company}?\n' 'Format instructions: {format_instructions}'
        )

        # The parser
        parser_symbol = PydanticOutputParser(pydantic_object=TickerSymbol)

        # The prompt
        prompt_symbol = PromptTemplate(
            template=prompt_template_symbol,
            input_variables=['company'],
            partial_variables={'format_instructions': parser_symbol.get_format_instructions()},
        )

        # The chain
        chain_symbol = prompt_symbol | streamlit.session_state.fc.llm | parser_symbol

        # Invoke the chain to derive the ticker symbol of the company
        symbol = chain_symbol.invoke(company).symbol
        symbol_list.append(symbol)

    return list(set(symbol_list))


class RetrievalSymbolQuantitySchema(BaseModel):
    """
    Retrieve a list of ticker symbols and the quantity that the user wants to analyze.

    The quantity must be one of the following:

    Open, High, Low, Close, Volume, Dividends, Stock Splits.
    If you can't retrieve the quantity, use 'Close'.
    """

    symbol_list: List[str] = Field('List of stock ticker symbols', examples=['AAPL', 'MSFT'])
    quantity: str = Field('Quantity to analize', examples=['Open', 'Close'])


@tool(args_schema=RetrievalSymbolQuantitySchema)
def retrieve_symbol_quantity_list(symbol_list: List[str], quantity: str) -> Tuple[List[str], str]:
    """Retrieve a list of ticker symbols and the quantity that the user wants to analyze."""

    return symbol_list, quantity


class HistoricalPriceSchema(BaseModel):
    """Fetch historical stock prices for a given list of ticker symbols from `start_date` to `end_date`."""

    symbol_list: List[str] = Field('List of stock ticker symbol.')
    quantity: str = Field('Quantity to analize', examples=['Open', 'Close'])
    end_date: datetime.date = Field(
        'Typically today unless a specific end date is provided. End date MUST be greater than start date.'
    )
    start_date: datetime.date = Field(
        "Set explicitly, or calculated as 'end_date - date interval' "
        "(for example, if prompted 'over the past 6 months', "
        "date interval = 6 months so start_date would be 6 months earlier than today's date). "
        "Default to '1900-01-01' if vaguely asked for historical price. "
        'Start date must always be before the current date'
    )


@tool(args_schema=HistoricalPriceSchema)
def get_historical_price(
    symbol_list: List[str], quantity: str, start_date: datetime.date, end_date: datetime.date
) -> pandas.DataFrame:
    """
    Fetch historical stock prices for a given list of ticker symbols from 'start_date' to 'end_date'.

    Args:
        symbol: Stock ticker symbol.
        quantity: Quantity to analize.
        end_date: Typically today unless a specific end date is provided. End date MUST be greater than start date
        start_date: Set explicitly, or calculated as 'end_date - date interval'
            (for example, if prompted 'over the past 6 months',
            date interval = 6 months so start_date would be 6 months earlier than today's date).
            Default to '1900-01-01' if vaguely asked for historical price.
            Start date must always be before the current date.

    Returns:
        A `pandas DataFrame` with historical price data.
    """

    # Initialise a pandas DataFrame with symbols as columns and dates as index
    data_price = pandas.DataFrame(columns=symbol_list)

    # Fetch historical price data from Yahoo Finance
    for symbol in symbol_list:
        data = yfinance.Ticker(symbol)
        data_history = data.history(start=start_date, end=end_date)
        data_price[symbol] = data_history[quantity]

    # Plot the historical data
    fig = plot_price_over_time(data_price)
    return fig, data_price, symbol_list


def plot_price_over_time(data_close: pandas.DataFrame) -> Figure:
    """Plot the historical data over time."""

    full_df = pandas.DataFrame(columns=['Date'])
    for column in data_close:
        full_df = full_df.merge(data_close[column], on='Date', how='outer')

    # Create a matplotlib figure
    fig, ax = pyplot.subplots(figsize=(12, 6))

    # Dynamically plot each stock symbol in the DataFrame
    for column in full_df.columns[1:]:  # Skip the first column since it's the date
        ax.plot(full_df['Date'], full_df[column], label=column, marker='o', markersize=2, linestyle='-', linewidth=1.5)

    # Set title and labels
    ax.set_title('Stock Price Over Time: ' + ', '.join(full_df.columns.tolist()[1:]))
    ax.set_xlabel('Date')
    ax.set_ylabel('Stock Price (USD)')

    from matplotlib.ticker import FuncFormatter

    # Format y-axis ticks
    ax.yaxis.set_major_formatter(FuncFormatter(lambda x, p: f'${x:,.2f}'))

    # Format x-axis
    ax.xaxis.set_major_locator(mdates.AutoDateLocator())  # type: ignore
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))  # type: ignore

    # Rotate and align the tick labels so they look better
    pyplot.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')

    # Add grid
    ax.grid(True, axis='x', linestyle='--', alpha=0.7)
    ax.grid(True, axis='y', linestyle='--', alpha=0.7)

    # Customize colors
    ax.set_facecolor('lightgray')
    fig.patch.set_facecolor('lightgray')

    # Add legend
    ax.legend(title='Stock Symbol', loc='upper left', bbox_to_anchor=(1, 1))

    # Adjust layout to prevent cutting off labels
    pyplot.tight_layout()

    return fig
